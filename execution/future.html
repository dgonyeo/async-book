<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Future Trait - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="../getting_started/chapter.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="../getting_started/chapter.html"><strong aria-hidden="true">1.1.</strong> What This Book Covers</a></li><li><a href="../getting_started/why_async.html"><strong aria-hidden="true">1.2.</strong> Why Async?</a></li><li><a href="../getting_started/state_of_async_rust.html"><strong aria-hidden="true">1.3.</strong> The State of Asynchronous Rust</a></li><li><a href="../getting_started/async_await_primer.html"><strong aria-hidden="true">1.4.</strong> async/await! Primer</a></li><li><a href="../getting_started/http_server_example.html"><strong aria-hidden="true">1.5.</strong> Applied: HTTP Server</a></li></ol></li><li><a href="../execution/chapter.html"><strong aria-hidden="true">2.</strong> Under the Hood: Executing Futures and Tasks</a></li><li><ol class="section"><li><a href="../execution/future.html" class="active"><strong aria-hidden="true">2.1.</strong> The Future Trait</a></li><li><a href="../execution/wakeups.html"><strong aria-hidden="true">2.2.</strong> Task Wakeups with LocalWaker and Waker</a></li><li><ol class="section"><li><a href="../execution/wakeups.html"><strong aria-hidden="true">2.2.1.</strong> Applied: Build a Timer</a></li></ol></li><li><a href="../execution/executor.html"><strong aria-hidden="true">2.3.</strong> Applied: Build an Executor</a></li><li><a href="../execution/io.html"><strong aria-hidden="true">2.4.</strong> Executors and System IO</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">3.</strong> TODO: async/await</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">3.1.</strong> TODO: What and Why</a></li><li><a href="../404.html"><strong aria-hidden="true">3.2.</strong> TODO: async Blocks, Closures, and Functions</a></li><li><a href="../404.html"><strong aria-hidden="true">3.3.</strong> TODO: Applied: XXX</a></li></ol></li><li><a href="../pinning/chapter.html"><strong aria-hidden="true">4.</strong> Pinning</a></li><li><ol class="section"><li><a href="../pinning/chapter.html"><strong aria-hidden="true">4.1.</strong> Practical Usage</a></li></ol></li><li><a href="../streams/chapter.html"><strong aria-hidden="true">5.</strong> Streams</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">5.1.</strong> TODO: Patterns: Iteration and Concurrency</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">6.</strong> TODO: Executing Multiple Futures at a Time</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">6.1.</strong> TODO: select! and join!</a></li><li><a href="../404.html"><strong aria-hidden="true">6.2.</strong> TODO: Spawning</a></li><li><a href="../404.html"><strong aria-hidden="true">6.3.</strong> TODO: Cancellation and Timeouts</a></li><li><a href="../404.html"><strong aria-hidden="true">6.4.</strong> TODO: FuturesUnordered</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">7.</strong> TODO: I/O</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">7.1.</strong> TODO: AsyncRead and AsyncWrite</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">8.</strong> TODO: Asynchronous Design Patterns: Solutions and Suggestions</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">8.1.</strong> TODO: Modeling Servers and the Request/Response Pattern</a></li><li><a href="../404.html"><strong aria-hidden="true">8.2.</strong> TODO: Managing Shared State</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">9.</strong> TODO: The Ecosystem: Tokio and More</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">9.1.</strong> TODO: Lots, lots more?...</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-future-trait" id="the-future-trait"><h1>The <code>Future</code> Trait</h1></a>
<p>The <code>Future</code> trait is at the center of asynchronous programming in Rust.
A <code>Future</code> is an asynchronous computation that can produce a value
(although that value may be empty, e.g. <code>()</code>). A <em>simplified</em> version of
the future trait might look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait SimpleFuture {
    type Output;
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
#}</code></pre></pre>
<p>Futures can be advanced by calling the <code>poll</code> function, which will drive the
future as far towards completion as possible. If the future completes, it
returns <code>Poll::Ready(result)</code>. If the future is not able to complete yet, it
returns <code>Poll::Pending</code> and arranges for the <code>wake()</code> function to be called
when the <code>Future</code> is ready to make more progress. When <code>wake()</code> is called, the
executor driving the <code>Future</code> will call <code>poll</code> again so that the <code>Future</code> can
make more progress.</p>
<p>Without <code>wake()</code>, the executor would have no way of knowing when a particular
future could make progress, and would have to be constantly polling every
future. With <code>wake()</code>, the executor knows exactly which futures are ready to
be <code>poll</code>ed.</p>
<p>For example, consider the case where we want to read from a socket that may
or may not have data available already. If there is data, we can read it
in and return <code>Poll::Ready(data)</code>, but if no data is ready, our future is
blocked and can no longer make progress. When no data is available, we
must register <code>wake</code> to be called when data becomes ready on the socket,
which will tell the executor that our future is ready to make progress.
A simple <code>SocketRead</code> future might look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // The socket has data-- read it into a buffer and return it.
            Poll::Ready(self.socket.read_buf())
        } else {
            // The socket does not yet have data.
            //
            // Arrange for `wake` to be called once data is available.
            // When data becomes available, `wake` will be called, and the
            // user of this `Future` will know to call `poll` again and
            // receive data.
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
#}</code></pre></pre>
<p>This model of <code>Future</code>s allows for composing together multiple asynchronous
operations without needing intermediate allocations. Running multiple futures
at once or chaining futures together can be implemented via allocation-free
state machines, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A SimpleFuture that runs two other futures to completion concurrently.
///
/// Concurrency is achieved via the fact that calls to `poll` each future
/// may be interleaved, allowing each future to advance itself at its own pace.
struct Join2 {
    // Each field may contain a future that should be run to completion.
    // If the future has already completed, the field is set to `None`.
    a: Option&lt;FutureA&gt;,
    b: Option&lt;FutureB&gt;,
}

impl SimpleFuture for Join2 {
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        // Attempt to complete future `a`.
        let finished_a = match &amp;mut self.a {
            Some(a) =&gt; {
                match a.poll(wake) {
                    Poll::Ready(()) =&gt; true,
                    Poll::Pending =&gt; false,
                }
            }
            None =&gt; true,
        };
        if finished_a { self.a.take() }

        // Attempt to complete future `b`.
        let finished_b = match &amp;mut self.b {
            Some(b) =&gt; {
                match b.poll(wake) {
                    Poll::Ready(()) =&gt; true,
                    Poll::Pending =&gt; false,
                }
            }
            None =&gt; true,
        };
        if finished_b { self.b.take() }

        if finished_a &amp;&amp; finished_b {
            // Both futures have completed-- we can return successfully
            Poll::Ready(())
        } else {
            // One or both futures still have work to do, and will call
            // `wake()` when progress can be made.
            Poll::Pending
        }
    }
}
#}</code></pre></pre>
<p>This shows how multiple futures can be run simultaneously without needing
separate allocations, allowing for more efficient asynchronous programs.
Similarly, multiple sequential futures can be run one after another, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A SimpleFuture that runs two futures to completion, one after another.
//
// Note: for the purposes of this simple example, `AndThenFut` assumes both
// the first and second futures are available at creation-time. The real
// `AndThen` combinator allows creating the second future based on the output
// of the first future, like `get_breakfast.and_then(|food| eat(food))`.
enum AndThenFut {
    first: Option&lt;FutureA&gt;,
    second: FutureB,
}

impl SimpleFuture for AndThenFut {
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if let Some(first) = &amp;mut self.first {
            match first.poll(wake) {
                // We've completed the first future-- remove it and start on
                // the second!
                Poll::Ready(()) =&gt; self.first.take(),
                // We couldn't yet complete the first future.
                Poll::Pending =&gt; return Poll::Pending,
            }
        }
        // Now that the first future is done, attempt to complete the second.
        second.poll(wake)
    }
}
#}</code></pre></pre>
<p>These examples show how the <code>Future</code> trait can be used to express asynchronous
control flow without requiring multiple allocated objects and deeply nested
callbacks. With the basic control-flow out of the way, let's talk about the
real <code>Future</code> trait and how it is different.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Future {
    type Output;
    fn poll(
        // note the change from `&amp;mut self` to `Pin&lt;&amp;mut Self&gt;`
        self: Pin&lt;&amp;mut Self&gt;, 
        lw: &amp;LocalWaker, // note the change from `wake: fn()`
    ) -&gt; Poll&lt;Self::Output&gt;;
}
#}</code></pre></pre>
<p>The first change you'll notice is that our <code>self</code> type is no longer <code>&amp;mut self</code>,
but has changed to <code>Pin&lt;&amp;mut Self&gt;</code>. We'll talk more about pinning in <a href="TODO">a later
section</a>, but for now know that it allows us to create futures that
are immovable. Immovable objects can store pointers between their fields,
e.g. <code>struct MyFut { a: i32, ptr_to_a: *const i32 }</code>. This feature is necessary
in order to enable async/await.</p>
<p>Secondly, <code>wake: fn()</code> has changed to <code>LocalWaker</code>. In <code>SimpleFuture</code>, we used
a call to a function pointer (<code>fn()</code>) to tell the future executor that the
future in question should be polled. However, since <code>fn()</code> is zero-sized, it
can't store any data about <em>which</em> <code>Future</code> called <code>wake</code>.
In a real-world scenario, a complex application like a web server may have
thousands of different connections whose wakeups should all be
managed separately. This is where <code>LocalWaker</code> and its sibling type <code>Waker</code>
come in.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../execution/chapter.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../execution/wakeups.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../execution/chapter.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../execution/wakeups.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
