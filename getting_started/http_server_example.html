<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Applied: HTTP Server - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="../getting_started/chapter.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="../getting_started/chapter.html"><strong aria-hidden="true">1.1.</strong> What This Book Covers</a></li><li><a href="../getting_started/why_async.html"><strong aria-hidden="true">1.2.</strong> Why Async?</a></li><li><a href="../getting_started/state_of_async_rust.html"><strong aria-hidden="true">1.3.</strong> The State of Asynchronous Rust</a></li><li><a href="../getting_started/async_await_primer.html"><strong aria-hidden="true">1.4.</strong> async/await! Primer</a></li><li><a href="../getting_started/http_server_example.html" class="active"><strong aria-hidden="true">1.5.</strong> Applied: HTTP Server</a></li></ol></li><li><a href="../execution/chapter.html"><strong aria-hidden="true">2.</strong> Under the Hood: Executing Futures and Tasks</a></li><li><ol class="section"><li><a href="../execution/future.html"><strong aria-hidden="true">2.1.</strong> The Future Trait</a></li><li><a href="../execution/wakeups.html"><strong aria-hidden="true">2.2.</strong> Task Wakeups with LocalWaker and Waker</a></li><li><ol class="section"><li><a href="../execution/wakeups.html"><strong aria-hidden="true">2.2.1.</strong> Applied: Build a Timer</a></li></ol></li><li><a href="../execution/executor.html"><strong aria-hidden="true">2.3.</strong> Applied: Build an Executor</a></li><li><a href="../execution/io.html"><strong aria-hidden="true">2.4.</strong> Executors and System IO</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">3.</strong> TODO: async/await</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">3.1.</strong> TODO: What and Why</a></li><li><a href="../404.html"><strong aria-hidden="true">3.2.</strong> TODO: async Blocks, Closures, and Functions</a></li><li><a href="../404.html"><strong aria-hidden="true">3.3.</strong> TODO: Applied: XXX</a></li></ol></li><li><a href="../pinning/chapter.html"><strong aria-hidden="true">4.</strong> Pinning</a></li><li><ol class="section"><li><a href="../pinning/chapter.html"><strong aria-hidden="true">4.1.</strong> Practical Usage</a></li></ol></li><li><a href="../streams/chapter.html"><strong aria-hidden="true">5.</strong> Streams</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">5.1.</strong> TODO: Patterns: Iteration and Concurrency</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">6.</strong> TODO: Executing Multiple Futures at a Time</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">6.1.</strong> TODO: select! and join!</a></li><li><a href="../404.html"><strong aria-hidden="true">6.2.</strong> TODO: Spawning</a></li><li><a href="../404.html"><strong aria-hidden="true">6.3.</strong> TODO: Cancellation and Timeouts</a></li><li><a href="../404.html"><strong aria-hidden="true">6.4.</strong> TODO: FuturesUnordered</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">7.</strong> TODO: I/O</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">7.1.</strong> TODO: AsyncRead and AsyncWrite</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">8.</strong> TODO: Asynchronous Design Patterns: Solutions and Suggestions</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">8.1.</strong> TODO: Modeling Servers and the Request/Response Pattern</a></li><li><a href="../404.html"><strong aria-hidden="true">8.2.</strong> TODO: Managing Shared State</a></li></ol></li><li><a href="../404.html"><strong aria-hidden="true">9.</strong> TODO: The Ecosystem: Tokio and More</a></li><li><ol class="section"><li><a href="../404.html"><strong aria-hidden="true">9.1.</strong> TODO: Lots, lots more?...</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#applied-simple-http-server" id="applied-simple-http-server"><h1>Applied: Simple HTTP Server</h1></a>
<p>Let's use <code>async</code>/<code>await!</code> to build an echo server!</p>
<p>To start, run <code>rustup update nightly</code> to make sure you've got the latest and
greatest copy of Rust-- we're working with bleeding-edge features, so it's
essential to stay up-to-date. Once you've done that, run
<code>cargo +nightly new async-await-echo</code> to create a new project, and open up
the resulting <code>async-await-echo</code> folder.</p>
<p>Let's add some dependencies to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]

# The latest version of the &quot;futures&quot; library, which has lots of utilities
# for writing async code. Enable the &quot;tokio-compat&quot; feature to include the
# functions for using futures 0.3 and async/await with the Tokio library.
futures-preview = { version = &quot;0.3.0-alpha.9&quot;, features = [&quot;tokio-compat&quot;] }

# Hyper is an asynchronous HTTP library. We'll use it to power our HTTP
# server and to make HTTP requests.
hyper = &quot;0.12.9&quot;

# Tokio is a runtime for asynchronous I/O applications. Hyper uses
# it for the default server runtime. The `tokio` crate also provides an
# an `await!` macro similar to the one in `std`, but it supports `await!`ing
# both futures 0.1 futures (the kind used by Hyper and Tokio) and
# futures 0.3 futures (the kind produced by the new `async`/`await!` language
# feature).
tokio = { version = &quot;0.1.11&quot;, features = [&quot;async-await-preview&quot;] }
</code></pre>
<p>Now that we've got our dependencies out of the way, let's start writing some
code. Open up <code>src/main.rs</code> and enable the following features at the top of
the file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(async_await, await_macro, futures_api)]
#fn main() {
#}</code></pre></pre>
<ul>
<li><code>async_await</code> adds support for the <code>async fn</code> syntax.</li>
<li><code>await_macro</code> adds support for the <code>await!</code> macro.</li>
<li><code>futures_api</code> adds support for the nightly <code>std::future</code> and <code>std::task</code>
modules which define the core <code>Future</code> trait and dependent types.</li>
</ul>
<p>Additionally, we have some imports to add:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use {
    hyper::{
        // Miscellaneous types from Hyper for working with HTTP.
        Body, Client, Request, Response, Server, Uri,

        // This function turns a closure which returns a future into an
        // implementation of the the Hyper `Service` trait, which is an
        // asynchronous function from a generic `Request` to a `Response`.
        service::service_fn,

        // A function which runs a future to completion using the Hyper runtime.
        rt::run,
    },
    futures::{
        // `TokioDefaultSpawner` tells futures 0.3 futures how to spawn tasks
        // onto the Tokio runtime.
        compat::TokioDefaultSpawner,

        // Extension traits providing additional methods on futures.
        // `FutureExt` adds methods that work for all futures, whereas
        // `TryFutureExt` adds methods to futures that return `Result` types.
        future::{FutureExt, TryFutureExt},
    },
    std::net::SocketAddr,

    // This is the redefinition of the await! macro which supports both
    // futures 0.1 (used by Hyper and Tokio) and futures 0.3 (the new API
    // exposed by `std::future` and implemented by `async fn` syntax).
    tokio::await,
};
#}</code></pre></pre>
<p>Once the imports are out of the way, we can start putting together the
boilerplate to allow us to serve requests:</p>
<pre><pre class="playpen"><code class="language-rust">async fn serve_req(req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, hyper::Error&gt; {
    unimplemented!()
}

async fn run_server(addr: SocketAddr) {
    println!(&quot;Listening on http://{}&quot;, addr);

    // Create a server bound on the provided address
    let serve_future = Server::bind(&amp;addr)
        // Serve requests using our `async serve_req` function.
        // `serve` takes a closure which returns a type implementing the
        // `Service` trait. `service_fn` returns a value implementing the
        // `Service` trait, and accepts a closure which goes from request
        // to a future of the response. In order to use our `serve_req`
        // function with Hyper, we have to box it and put it in a compatability
        // wrapper to go from a futures 0.3 future (the kind returned by
        // `async fn`) to a futures 0.1 future (the kind used by Hyper).
        .serve(|| service_fn(|req|
            serve_req(req).boxed().compat(TokioDefaultSpawner)
        ));

    // Wait for the server to complete serving or exit with an error.
    // If an error occurred, print it to stderr.
    if let Err(e) = await!(serve_future) {
        eprintln!(&quot;server error: {}&quot;, e);
    }
}

fn main() {
    // Set the address to run our socket on.
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));

    // Call our run_server function, which returns a future.
    // As with every `async fn`, we need to run that future in order for
    // `run_server` to do anything. Additionally, since `run_server` is an
    // `async fn`, we need to convert it from a futures 0.3 future into a
    // futures 0.1 future.
    let futures_03_future = run_server(addr);
    let futures_01_future =
        futures_03_future.unit_error().boxed().compat(TokioDefaultSpawner);

    // Finally, we can run the future to completion using the `run` function
    // provided by Hyper.
    run(futures_01_future);
}
</code></pre></pre>
<p>If you <code>cargo run</code> now, you should see the message &quot;Listening on
http://127.0.0.1:300&quot; printed on your terminal. If you open that URL in your
browser of choice, you'll see &quot;thread ... panicked at 'not yet implemented'.&quot;
Great! Now we just need to actually handle requests. To start, let's just
return a static message:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn serve_req(req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, hyper::Error&gt; {
    // Always return successfully with a response containing a body with
    // a friendly greeting ;)
    Ok(Response::new(Body::from(&quot;hello, world!&quot;)))
}
#}</code></pre></pre>
<p>If you <code>cargo run</code> again and refresh the page, you should see &quot;hello, world!&quot;
appear in your browser. Congratulations! You just wrote your first asynchronous
webserver in Rust.</p>
<p>You can also inspect the request itself, which contains information such as
the request URI, HTTP version, headers, and other metadata. For example, we
can print out the URI of the request like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;Got request at {:?}&quot;, req.uri());
#}</code></pre></pre>
<p>You may have noticed that we're not yet doing
anything asynchronous when handling the request-- we just respond immediately,
so we're not taking advantage of the flexibility that <code>async fn</code> gives us.
Rather than just returning a static message, let's try proxying the user's
request to another website using Hyper's HTTP client.</p>
<p>We start by parsing out the URL we want to request:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let url_str = &quot;http://www.rust-lang.org/en-US/&quot;;
let url = url_str.parse::&lt;Uri&gt;().expect(&quot;failed to parse URL&quot;);
#}</code></pre></pre>
<p>Then we can create a new <code>hyper::Client</code> and use it to make a <code>GET</code> request,
returning the response to the user:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let res = await!(Client::new().get(url));
// Return the result of the request directly to the user
println!(&quot;request finished --returning response&quot;);
res
#}</code></pre></pre>
<p><code>Client::get</code> returns a <code>hyper::client::FutureResponse</code>, which implements
<code>Future&lt;Output = Result&lt;Response, Error&gt;&gt;</code>
(or <code>Future&lt;Item = Response, Error = Error&gt;</code> in futures 0.1 terms).
When we <code>await!</code> that future, an HTTP request is sent out, the current task
is suspended, and the task is queued to be continued once a response has
become available.</p>
<p>Now, if you <code>cargo run</code> and open <code>http://127.0.0.1:3000/foo</code> in your browser,
you'll see the Rust homepage, and the following terminal output:</p>
<pre><code>Listening on http://127.0.0.1:3000
Got request at /foo
making request to http://www.rust-lang.org/en-US/
request finished-- returning response
</code></pre>
<p>Congratulations! You just proxied an HTTP request.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../getting_started/async_await_primer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../execution/chapter.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../getting_started/async_await_primer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../execution/chapter.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
